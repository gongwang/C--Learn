/************************************************************************/
/* 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

输入: [2,2,1]
输出: 1
示例 2:

输入: [4,1,2,1,2]
输出: 4

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/single-number
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。                                                                     */
/************************************************************************/


/************************************************************************/
/* 
经典的位运算
这道题目已经广为流传了，扫描数组，使用异或运算，最终的结果即是答案。
至于为什么异或运算是题解，首先需要了解以下几点：

什么是异或运算(xor)：1 xor 1 = 0, 0 xor 0 = 0, 1 xor 0 = 1, 0 xor 1 = 1
知道了什么是异或运算之后，就可以得出任意数字异或其自身等于0的结论。比如数字5，其二进制是101，那么就有101 xor 101 = 0
知道了什么是异或运算之后，就可以得出任意数字异或0等于其本身的结论。
位运算与顺序无关，即a xor b = b xor a, a xor b xor a = a xor a xor b = b
因此，对于数组内只有一个数字出现了奇数次，其余数字都是出现偶数次的情况，异或运算刚好完美解决这个问题。

class Solution {
    public:
    int singleNumber(vector<int>& nums) {
    int num = 0;
    for (vector<int>::size_type i = 0; i < nums.size(); ++i)
    num ^= nums[i];
    return num;
}
};


*/
/************************************************************************/

class SolutionOnceNum {
public:
    int singleNumber(vector<int>& nums) {

        sort(nums.begin(), nums.end()); //先进行排序

        for(int nIndex = 0; nIndex < nums.size() -1; nIndex++) //单次移动两步
        {
            if (nums[nIndex] != nums[nIndex+1])
            {
                return nums[nIndex];
            }
            nIndex++;
        }
        return nums[nums.size() -1]; //如果循环内 未退出，证明最后一个为特殊的值，直接进行返回
    }
};